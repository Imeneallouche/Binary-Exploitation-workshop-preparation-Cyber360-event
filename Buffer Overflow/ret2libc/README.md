<h1> Here is  a LIBC </h1>

```yaml
Type: Writeup

Theme: Return to LIBC buffer overflow attack

Language used: Python and C

Competences achieved:
  - Vocabulary: PLT, GOT, LIBC, ASLR
  - finding payload
  - finding address of bin/sh in the LIBC
  - finding the gadgets using ROPgadget
  - Constructing a ROP chain
  
Platform: PicoCTF

Category: Binary exploitation

Link: https://play.picoctf.org/practice/challenge/179?category=6&page=1
```
<br><br>
<h3> 1- General information about the binary file </h3>

by running the command <b>Checksec</b> we can notice that it is an amd64 architecture and that the stack is not executable (NX enabled) , no stack canary and PIE
  
![image](https://user-images.githubusercontent.com/89279264/222975343-87adefd4-a159-4e2c-b2e1-bd5d1f746a7e.png)


<br><br>

<h3> 2- Decompiling the binary</h3>

Using <b>Ghidra</b>, we can spot two interesting functions: Main and Do staff 
- Main functinon calls Do_staff function infinitly then calls the <b>puts function</b> that we know that it comes from LIBC library
- Do staff does simply take a string (buffer of 112 chars max) , converts the chars in even positions to uppercase and chars in odd positions to lowercase

![image](https://user-images.githubusercontent.com/89279264/222975750-a52d9732-c836-4a44-8f21-c99d90933a36.png)

![image](https://user-images.githubusercontent.com/89279264/222975809-fd110c72-98cf-42d5-91fe-439f11f3f8f0.png)


<h3> 3- Finding the correct padding</h3>

I couldn't disassemble the binary file locally for some unseen reasons so I had to play with the padding remotly until I could crash the return address
- the padding found was <b>135</b>

![image](https://user-images.githubusercontent.com/89279264/222975917-1ea0c337-20e8-4cfa-a72c-00deb07d0281.png)

![image](https://user-images.githubusercontent.com/89279264/222975936-235b5a31-4081-4ba3-8061-7e4ea9161bd1.png)



